g};
resolve_inst({allocate,[{u,X0},{u,X1}]},_,_,_) ->
    {allocate,X0,X1};
resolve_inst({allocate_heap,[{u,X0},{u,X1},{u,X2}]},_,_,_) ->
    {allocate_heap,X0,X1,X2};
resolve_inst({allocate_zero,[{u,X0},{u,X1}]},_,_,_) ->
    {allocate_zero,X0,X1};
resolve_inst({allocate_heap_zero,[{u,X0},{u,X1},{u,X2}]},_,_,_) ->
    {allocate_heap_zero,X0,X1,X2};
resolve_inst({test_heap,[{u,X0},{u,X1}]},_,_,_) ->
    {test_heap,X0,X1};
resolve_inst({init,[Dst]},_,_,_) ->
    {init,Dst};
resolve_inst({deallocate,[{u,L}]},_,_,_) ->
    {deallocate,L};
resolve_inst({return,[]},_,_,_) ->
    return;
resolve_inst({send,[]},_,_,_) ->
    send;
resolve_inst({remove_message,[]},_,_,_) ->
    remove_message;
resolve_inst({timeout,[]},_,_,_) ->
    timeout;
resolve_inst({loop_rec,[Lbl,Dst]},_,_,_) ->
    {loop_rec,Lbl,Dst};
resolve_inst({loop_rec_end,[Lbl]},_,_,_) ->
    {loop_rec_end,Lbl};
resolve_inst({wait,[Lbl]},_,_,_) ->
    {wait,Lbl};
resolve_inst({wait_timeout,[Lbl,Int]},_,_,_) ->
    {wait_timeout,Lbl,resolve_arg(Int)};
resolve_inst({m_plus,Args},_,_,_) ->
    [W,SrcR1,SrcR2,DstR] = resolve_args(Args),
    {arithbif,'+',W,[SrcR1,SrcR2],DstR};
resolve_inst({m_minus,Args},_,_,_) ->
    [W,SrcR1,SrcR2,DstR] = resolve_args(Args),
    {arithbif,'-',W,[SrcR1,SrcR2],DstR};
resolve_inst({m_times,Args},_,_,_) ->
    [W,SrcR1,SrcR2,DstR] = resolve_args(Args),
    {arithbif,'*',W,[SrcR1,SrcR2],DstR};
resolve_inst({m_div,Args},_,_,_) ->
    [W,SrcR1,SrcR2,DstR] = resolve_args(Args),
    {arithbif,'/',W,[SrcR1,SrcR2],DstR};
resolve_inst({int_div,Args},_,_,_) ->
    [W,SrcR1,SrcR2,DstR] = resolve_args(Args),
    {arithbif,'div',W,[SrcR1,SrcR2],DstR};
resolve_inst({int_rem,Args},_,_,_) ->
    [W,SrcR1,SrcR2,DstR] = resolve_args(Args),
    {arithbif,'rem',W,[SrcR1,SrcR2],DstR};
resolve_inst({int_band,Args},_,_,_) ->
    [W,SrcR1,SrcR2,DstR] = resolve_args(Args),
    {arithbif,'band',W,[SrcR1,SrcR2],DstR};
resolve_inst({int_bor,Args},_,_,_) ->
    [W,SrcR1,SrcR2,DstR] = resolve_args(Args),
    {arithbif,'bor',W,[SrcR1,SrcR2],DstR};
resolve_inst({int_bxor,Args},_,_,_) ->
    [W,SrcR1,SrcR2,DstR] = resolve_args(Args),
    {arithbif,'bxor',W,[SrcR1,SrcR2],DstR};
resolve_inst({int_bsl,Args},_,_,_) ->
    [W,SrcR1,SrcR2,DstR] = resolve_args(Args),
    {arithbif,'bsl',W,[SrcR1,SrcR2],DstR};
resolve_inst({int_bsr,Args},_,_,_) ->
    [W,SrcR1,SrcR2,DstR] = resolve_args(Args),
    {arithbif,'bsr',W,[SrcR1,SrcR2],DstR};
resolve_inst({int_bnot,Args},_,_,_) ->
    [W,SrcR,DstR] = resolve_args(Args),
    {arithbif,'bnot',W,[SrcR],DstR};
resolve_inst({is_lt=I,Args0},_,_,_) ->
    [L|Args] = resolve_args(Args0),
    {test,I,L,Args};
resolve_inst({is_ge=I,Args0},_,_,_) ->
    [L|Args] = resolve_args(Args0),
    {test,I,L,Args};
resolve_inst({is_eq=I,Args0},_,_,_) ->
    [L|Args] = resolve_args(Args0),
    {test,I,L,Args};
resolve_inst({is_ne=I,Args0},_,_,_) ->
    [L|Args] = resolve_args(Args0),
    {test,I,L,Args};
resolve_inst({is_eq_exact=I,Args0},_,_,_) ->
    [L|Args] = resolve_args(Args0),
    {test,I,L,Args};
resolve_inst({is_ne_exact=I,Args0},_,_,_) ->
    [L|Args] = resolve_args(Args0),
    {test,I,L,Args};
resolve_inst({is_integer=I,Args0},_,_,_) ->
    [L|Args] = resolve_args(Args0),
    {test,I,L,Args};
resolve_inst({is_float=I,Args0},_,_,_) ->
    [L|Args] = resolve_args(Args0),
    {test,I,L,Args};
resolve_inst({is_number=I,Args0},_,_,_) ->
    [L|Args] = resolve_args(Args0),
    {test,I,L,Args};
resolve_inst({is_atom=I,Args0},_,_,_) ->
    [L|Args] = resolve_args(Args0),
    {test,I,L,Args};
resolve_inst({is_pid=I,Args0},_,_,_) ->
    [L|Args] = resolve_args(Args0),
    {test,I,L,Args};
resolve_inst({is_reference=I,Args0},_,_,_) ->
    [L|Args] = resolve_args(Args0),
    {test,I,L,Args};
resolve_inst({is_port=I,Args0},_,_,_) ->
    [L|Args] = resolve_args(Args0),
    {test,I,L,Args};
resolve_inst({is_nil=I,Args0},_,_,_) ->
    [L|Args] = resolve_args(Args0),
    {test,I,L,Args};
resolve_inst({is_binary=I,Args0},_,_,_) ->
    [L|Args] = resolve_args(Args0),
    {test,I,L,Args};
resolve_inst({is_constant=I,Args0},_,_,_) ->
    [L|Args] = resolve_args(Args0),
    {test,I,L,Args};
resolve_inst({is_list=I,Args0},_,_,_) ->
    [L|Args] = resolve_args(Args0),
    {test,I,L,Args};
resolve_inst({is_nonempty_list=I,Args0},_,_,_) ->
    [L|Args] = resolve_args(Args0),
    {test,I,L,Args};
resolve_inst({is_tuple=I,Args0},_,_,_) ->
    [L|Args] = resolve_args(Args0),
    {test,I,L,Args};
resolve_inst({test_arity=I,Args0},_,_,_) ->
    [L|Args] = resolve_args(Args0),
    {test,I,L,Args};
resolve_inst({is_tagged_tuple=I,Args0},_,_,_) ->
    [F|Args] = resolve_args(Args0),
    {test,I,F,Args};
resolve_inst({select_val,Args},_,_,_) ->
    [Reg,FLbl,{{z,1},{u,_Len},List0}] = Args,
    List = resolve_args(List0),
    {select_val,Reg,FLbl,{list,List}};
resolve_inst({select_tuple_arity,Args},_,_,_) ->
    [Reg,FLbl,{{z,1},{u,_Len},List0}] = Args,
    List = resolve_args(List0),
    {select_tuple_arity,Reg,FLbl,{list,List}};
resolve_inst({jump,[Lbl]},_,_,_) ->
    {jump,Lbl};
resolve_inst({'catch',[Dst,Lbl]},_,_,_) ->
    {'catch',Dst,Lbl};
resolve_inst({catch_end,[Dst]},_,_,_) ->
    {catch_end,Dst};
resolve_inst({move,[Src,Dst]},_,_,_) ->
    {move,resolve_arg(Src),Dst};
resolve_inst({get_list,[Src,Dst1,Dst2]},_,_,_) ->
    {get_list,Src,Dst1,Dst2};
resolve_inst({get_tuple_element,[Src,{u,Off},Dst]},_,_,_) ->
    {get_tuple_element,resolve_arg(Src),Off,resolve_arg(Dst)};
resolve_inst({set_tuple_element,[Src,Dst,{u,Off}]},_,_,_) ->
    {set_tuple_element,resolve_arg(Src),resolve_arg(Dst),Off};
resolve_inst({put_string,[{u,Len},{u,Off},Dst]},_,Strings,_) ->
    String = if Len > 0 -> binary_to_list(Strings, Off+1, Off+Len);
		true -> ""
	     end,
    {put_string,Len,{string,String},Dst};
resolve_inst({put_list,[Src1,Src2,Dst]},_,_,_) ->
    {put_list,resolve_arg(Src1),resolve_arg(Src2),Dst};
resolve_inst({put_tuple,[{u,Arity},Dst]},_,_,_) ->
    {put_tuple,Arity,Dst};
resolve_inst({put,[Src]},_,_,_) ->
    {put,resolve_arg(Src)};
resolve_inst({badmatch,[X]},_,_,_) ->
    {badmatch,resolve_arg(X)};
resolve_inst({if_end,[]},_,_,_) ->
    if_end;
resolve_inst({case_end,[X]},_,_,_) ->
    {case_end,resolve_arg(X)};
resolve_inst({call_fun,[{u,N}]},_,_,_) ->
    {call_fun,N};
resolve_inst({make_fun,Args},_,_,Lbls) ->
    [{f,L},Magic,FreeVars] = resolve_args(Args),
    {make_fun,lookup(L,Lbls),Magic,FreeVars};
resolve_inst({is_function=I,Args0},_,_,_) ->
    [L|Args] = resolve_args(Args0),
    {test,I,L,Args};
resolve_inst({call_ext_only,[{u,N},{u,MFAix}]},Imports,_,_) ->
    {call_ext_only,N,lookup(MFAix+1,Imports)};
%%
%% Instructions for handling binaries added in R7A & R7B
%%
resolve_inst({bs_start_match,[F,Reg]},_,_,_) ->
    {bs_start_match,F,Reg};
resolve_inst({bs_get_integer=I,[Lbl,Arg2,{u,N},{u,U},Arg5]},_,_,_) ->
    [A2,A5] = resolve_args([Arg2,Arg5]),
    {test,I,Lbl,[A2,N,decode_field_flags(U),A5]};
resolve_inst({bs_get_float=I,[Lbl,Arg2,{u,N},{u,U},Arg5]},_,_,_) ->
    [A2,A5] = resolve_args([Arg2,Arg5]),
    {test,I,Lbl,[A2,N,decode_field_flags(U),A5]};
resolve_inst({bs_get_binary=I,[Lbl,Arg2,{u,N},{u,U},Arg5]},_,_,_) ->
    [A2,A5] = resolve_args([Arg2,Arg5]),
    {test,I,Lbl,[A2,N,decode_field_flags(U),A5]};
resolve_inst({bs_skip_bits,[Lbl,Arg2,{u,N},{u,U}]},_,_,_) ->
    A2 = resolve_arg(Arg2),
    {test,bs_skip_bits,Lbl,[A2,N,decode_field_flags(U)]};
resolve_inst({bs_test_tail,[F,{u,N}]},_,_,_) ->
    {test,bs_test_tail,F,[N]};
resolve_inst({bs_save,[{u,N}]},_,_,_) ->
    {bs_save,N};
resolve_inst({bs_restore,[{u,N}]},_,_,_) ->
    {bs_restore,N};
resolve_inst({bs_init,[{u,N},{u,U}]},_,_,_) ->
    {bs_init,N,decode_field_flags(U)};
resolve_inst({bs_final,[F,X]},_,_,_) ->
    {bs_final,F,X};
resolve_inst({bs_put_integer,[Lbl,Arg2,{u,N},{u,U},Arg5]},_,_,_) ->
    [A2,A5] = resolve_args([Arg2,Arg5]),
    {bs_put_integer,Lbl,A2,N,decode_field_flags(U),A5};
resolve_inst({bs_put_binary,[Lbl,Arg2,{u,N},{u,U},Arg5]},_,_,_) ->
    [A2,A5] = resolve_args([Arg2,Arg5]),
    {bs_put_binary,Lbl,A2,N,decode_field_flags(U),A5};
resolve_inst({bs_put_float,[Lbl,Arg2,{u,N},{u,U},Arg5]},_,_,_) ->
    [A2,A5] = resolve_args([Arg2,Arg5]),
    {bs_put_float,Lbl,A2,N,decode_field_flags(U),A5};
resolve_inst({bs_put_string,[{u,Len},{u,Off}]},_,Strings,_) ->
    String = if Len > 0 -> binary_to_list(Strings, Off+1, Off+Len);
		true -> ""
	     end,
    {bs_put_string,Len,{string,String}};
resolve_inst({bs_need_buf,[{u,N}]},_,_,_) ->
    {bs_need_buf,N};

%%
%% Instructions for handling floating point numbers added in June 2001 (R8).
%%
resolve_inst({fclearerror,[]},_,_,_) ->
    fclearerror;
resolve_inst({fcheckerror,[Arg]},_,_,_) ->
    {fcheckerror,resolve_arg(Arg)};
resolve_inst({fmove,Args},_,_,_) ->
    [FR,Reg] = resolve_args(Args),
    {fmove,FR,Reg};
resolve_inst({fconv,Args},_,_,_) ->
    [Reg,FR] = resolve_args(Args),
    {fconv,Reg,FR};
resolve_inst({fadd=I,Args},_,_,_) ->
    [F,A1,A2,Reg] = resolve_args(Args),
    {arithfbif,I,F,[A1,A2],Reg};
resolve_inst({fsub=I,Args},_,_,_) ->
    [F,A1,A2,Reg] = resolve_args(Args),
    {arithfbif,I,F,[A1,A2],Reg};
resolve_inst({fmul=I,Args},_,_,_) ->
    [F,A1,A2,Reg] = resolve_args(Args),
    {arithfbif,I,F,[A1,A2],Reg};
resolve_inst({fdiv=I,Args},_,_,_) ->
    [F,A1,A2,Reg] = resolve_args(Args),
    {arithfbif,I,F,[A1,A2],Reg};
resolve_inst({fnegate,Args},_,_,_) ->
    [F,Arg,Reg] = resolve_args(Args),
    {arithfbif,fnegate,F,[Arg],Reg};

%%
%% Instructions for try expressions added in January 2003 (R10).
%%
resolve_inst({'try',[Reg,Lbl]},_,_,_) -> % analogous to 'catch'
    {'try',Reg,Lbl};
resolve_inst({try_end,[Reg]},_,_,_) ->   % analogous to 'catch_end'
    {try_end,Reg};
resolve_inst({try_case,[Reg]},_,_,_) ->  % analogous to 'catch_end'
    {try_case,Reg};
resolve_inst({try_case_end,[Arg]},_,_,_) ->
    {try_case_end,resolve_arg(Arg)};
resolve_inst({raise,[_Reg1,_Reg2]=Regs},_,_,_) ->
    {raise,{f,0},Regs,{x,0}};		 % do NOT wrap this as a 'bif'
					 % as there is no raise/2 bif!

%%
%% New bit syntax instructions added in February 2004 (R10B).
%%
resolve_inst({bs_init2,[Lbl,Arg2,{u,W},{u,R},{u,F},Arg6]},_,_,_) ->
    [A2,A6] = resolve_args([Arg2,Arg6]),
    {bs_init2,Lbl,A2,W,R,decode_field_flags(F),A6};
resolve_inst({bs_bits_to_bytes,[Lbl,Arg2,Arg3]},_,_,_) ->
    [A2,A3] = resolve_args([Arg2,Arg3]),
    {bs_bits_to_bytes,Lbl,A2,A3};
resolve_inst({bs_add=I,[Lbl,Arg2,Arg3,Arg4,Arg5]},_,_,_) ->
    [A2,A3,A4,A5] = resolve_args([Arg2,Arg3,Arg4,Arg5]),
    {I,Lbl,[A2,A3,A4],A5};

%%
%% New apply instructions added in April 2004 (R10B).
%%
resolve_inst({apply,[{u,Arity}]},_,_,_) ->
    {apply,Arity};
resolve_inst({apply_last,[{u,Arity},{u,D}]},_,_,_) ->
    {apply_last,Arity,D};

%%
%% New test instruction added in April 2004 (R10B).
%%
resolve_inst({is_boolean=I,Args0},_,_,_) ->
    [L|Args] = resolve_args(Args0),
    {test,I,L,Args};

%%
%% New instruction added in June 2005.
%%
resolve_inst({is_function2=I,Args0},_,_,_) ->
    [L|Args] = resolve_args(Args0),
    {test,I,L,Args};

%%
%% New bit syntax matching added in Dec 2005 (R11B).
%%
resolve_inst({bs_start_match2=I,[F,Reg,{u,Live},{u,Max},Ms]},_,_,_) ->
    {test,I,F,[Reg,Live,Max,Ms]};
resolve_inst({bs_get_integer2=I,[Lbl,Ms,{u,Live},Arg2,{u,N},{u,U},Arg5]},_,_,_) ->
    [A2,A5] = resolve_args([Arg2,Arg5]),
    {test,I,Lbl,[Ms, Live,A2,N,decode_field_flags(U),A5]};
resolve_inst({bs_get_binary2=I,[Lbl,Ms,{u,Live},Arg2,{u,N},{u,U},Arg5]},_,_,_) ->
    [A2,A5] = resolve_args([Arg2,Arg5]),
    {test,I,Lbl,[Ms, Live,A2,N,decode_field_flags(U),A5]};
resolve_inst({bs_get_float2=I,[Lbl,Ms,{u,Live},Arg2,{u,N},{u,U},Arg5]},_,_,_) ->
    [A2,A5] = resolve_args([Arg2,Arg5]),
    {test,I,Lbl,[Ms, Live,A2,N,decode_field_flags(U),A5]};
resolve_inst({bs_skip_bits2=I,[Lbl,Ms,Arg2,{u,N},{u,U}]},_,_,_) ->
    A2 = resolve_arg(Arg2),
    {test,I,Lbl,[Ms,A2,N,decode_field_flags(U)]};
resolve_inst({bs_test_tail2=I,[F,Ms,{u,N}]},_,_,_) ->
    {test,I,F,[Ms,N]};
resolve_inst({bs_save2=I,[Ms,{u,N}]},_,_,_) ->
    {I,Ms,N};
resolve_inst({bs_restore2=I,[Ms,{u,N}]},_,_,_) ->
    {I,Ms,N};
resolve_inst({bs_save2=I,[Ms,{atom,_}=Atom]},_,_,_) ->
    %% New operand type in R12B.
    {I,Ms,Atom};
resolve_inst({bs_restore2=I,[Ms,{atom,_}=Atom]},_,_,_) ->
    %% New operand type in R12B.
    {I,Ms,Atom};

%%
%% New instructions for guard BIFs that may GC. Added in Jan 2006 (R11B).
%%
resolve_inst({gc_bif1,Args},Imports,_,_) ->
    [F,Live,Bif,A1,Reg] = resolve_args(Args),
    {extfunc,_Mod,BifName,_Arity} = lookup(Bif+1,Imports),
    {gc_bif,BifName,F,Live,[A1],Reg};
resolve_inst({gc_bif2,Args},Imports,_,_) ->
    [F,Live,Bif,A1,A2,Reg] = resolve_args(Args),
    {extfunc,_Mod,BifName,_Arity} = lookup(Bif+1,Imports),
    {gc_bif,BifName,F,Live,[A1,A2],Reg};

%%
%% New instruction in R14, gc_bif with 3 arguments
%%
resolve_inst({gc_bif3,Args},Imports,_,_) ->
    [F,Live,Bif,A1,A2,A3,Reg] = resolve_args(Args),
    {extfunc,_Mod,BifName,_Arity} = lookup(Bif+1,Imports),
    {gc_bif,BifName,F,Live,[A1,A2,A3],Reg};

%%
%% New instructions for creating non-byte aligned binaries.
%%
resolve_inst({bs_final2,[X,Y]},_,_,_) ->
    {bs_final2,X,Y};

%%
%% R11B-5.
%% 
resolve_inst({is_bitstr=I,Args0},_,_,_) ->
    [L|Args] = resolve_args(Args0),
    {test,I,L,Args};

%%
%% R12B.
%%
resolve_inst({bs_context_to_binary=I,[Reg0]},_,_,_) ->
    Reg = resolve_arg(Reg0),
    {I,Reg};
resolve_inst({bs_test_unit=I,[F,Ms,{u,N}]},_,_,_) ->
    {test,I,F,[Ms,N]};
resolve_inst({bs_match_string=I,[F,Ms,{u,Bits},{u,Off}]},_,Strings,_) ->
    Len = (Bits+7) div 8,
    String = if
		 Len > 0 -> 
		     <<_:Off/binary,Bin:Len/binary,_/binary>> = Strings,
		     Bin;
		 true -> <<>>
	     end,
    {test,I,F,[Ms,Bits,String]};
resolve_inst({bs_init_writable=I,[]},_,_,_) ->
    I;
resolve_inst({bs_append=I,[Lbl,Arg2,{u,W},{u,R},{u,U},Arg6,{u,F},Arg8]},_,_,_) ->
    [A2,A6,A8] = resolve_args([Arg2,Arg6,Arg8]),
    {I,Lbl,A2,W,R,U,A6,decode_field_flags(F),A8};
resolve_inst({bs_private_append=I,[Lbl,Arg2,{u,U},Arg4,{u,F},Arg6]},_,_,_) ->
    [A2,A4,A6] = resolve_args([Arg2,Arg4,Arg6]),
    {I,Lbl,A2,U,A4,decode_field_flags(F),A6};
resolve_inst({trim=I,[{u,N},{u,Remaining}]},_,_,_) ->
    {I,N,Remaining};
resolve_inst({bs_init_bits,[Lbl,Arg2,{u,W},{u,R},{u,F},Arg6]},_,_,_) ->
    [A2,A6] = resolve_args([Arg2,Arg6]),
    {bs_init_bits,Lbl,A2,W,R,decode_field_flags(F),A6};

%%
%% R12B-5.
%%
resolve_inst({bs_get_utf8=I,[Lbl,Arg2,Arg3,{u,U},Arg4]},_,_,_) ->
    [A2,A3,A4] = resolve_args([Arg2,Arg3,Arg4]),
    {test,I,Lbl,[A2,A3,decode_field_flags(U),A4]};
resolve_inst({bs_skip_utf8=I,[Lbl,Arg2,Arg3,{u,U}]},_,_,_) ->
    [A2,A3] = resolve_args([Arg2,Arg3]),
    {test,I,Lbl,[A2,A3,decode_field_flags(U)]};
resolve_inst({bs_get_utf16=I,[Lbl,Arg2,Arg3,{u,U},Arg4]},_,_,_) ->
    [A2,A3,A4] = resolve_args([Arg2,Arg3,Arg4]),
    {test,I,Lbl,[A2,A3,decode_field_flags(U),A4]};
resolve_inst({bs_skip_utf16=I,[Lbl,Arg2,Arg3,{u,U}]},_,_,_) ->
    [A2,A3] = resolve_args([Arg2,Arg3]),
    {test,I,Lbl,[A2,A3,decode_field_flags(U)]};
resolve_inst({bs_get_utf32=I,[Lbl,Arg2,Arg3,{u,U},Arg4]},_,_,_) ->
    [A2,A3,A4] = resolve_args([Arg2,Arg3,Arg4]),
    {test,I,Lbl,[A2,A3,decode_field_flags(U),A4]};
resolve_inst({bs_skip_utf32=I,[Lbl,Arg2,Arg3,{u,U}]},_,_,_) ->
    [A2,A3] = resolve_args([Arg2,Arg3]),
    {test,I,Lbl,[A2,A3,decode_field_flags(U)]};
resolve_inst({bs_utf8_size=I,[Lbl,Arg2,Arg3]},_,_,_) ->
    [A2,A3] = resolve_args([Arg2,Arg3]),
    {I,Lbl,A2,A3};
resolve_inst({bs_put_utf8=I,[Lbl,{u,U},Arg3]},_,_,_) ->
    A3 = resolve_arg(Arg3),
    {I,Lbl,decode_field_flags(U),A3};
resolve_inst({bs_utf16_size=I,[Lbl,Arg2,Arg3]},_,_,_) ->
    [A2,A3] = resolve_args([Arg2,Arg3]),
    {I,Lbl,A2,A3};
resolve_inst({bs_put_utf16=I,[Lbl,{u,U},Arg3]},_,_,_) ->
    A3 = resolve_arg(Arg3),
    {I,Lbl,decode_field_flags(U),A3};
resolve_inst({bs_put_utf32=I,[Lbl,{u,U},Arg3]},_,_,_) ->
    A3 = resolve_arg(Arg3),
    {I,Lbl,decode_field_flags(U),A3};

%%
%% R13B03.
%%
resolve_inst({on_load,[]},_,_,_) ->
    on_load;

%%
%% R14A.
%%
resolve_inst({recv_mark,[Lbl]},_,_,_) ->
    {recv_mark,Lbl};
resolve_inst({recv_set,[Lbl]},_,_,_) ->
    {recv_set,Lbl};

%%
%% R15A.
%%
resolve_inst({line,[Index]},_,_,_) ->
    {line,resolve_arg(Index)};

%%
%% 17.0
%%
resolve_inst({put_map_assoc,Args},_,_,_) ->
    [FLbl,Src,Dst,{u,N},{{z,1},{u,_Len},List0}] = Args,
    List = resolve_args(List0),
    {put_map_assoc,FLbl,Src,Dst,N,{list,List}};
resolve_inst({put_map_exact,Args},_,_,_) ->
    [FLbl,Src,Dst,{u,N},{{z,1},{u,_Len},List0}] = Args,
    List = resolve_args(List0),
    {put_map_exact,FLbl,Src,Dst,N,{list,List}};
resolve_inst({is_map=I,Args0},_,_,_) ->
    [FLbl|Args] = resolve_args(Args0),
    {test,I,FLbl,Args};
resolve_inst({has_map_fields,Args0},_,_,_) ->
    [FLbl,Src,{{z,1},{u,_Len},List0}] = Args0,
    List = resolve_args(List0),
    {test,has_map_fields,FLbl,Src,{list,List}};
resolve_inst({get_map_elements,Args0},_,_,_) ->
    [FLbl,Src,{{z,1},{u,_Len},List0}] = Args0,
    List = resolve_args(List0),
    {get_map_elements,FLbl,Src,{list,List}};

%%
%% Catches instructions that are not yet handled.
%%
resolve_inst(X,_,_,_) -> ?exit({resolve_inst,X}).

%%-----------------------------------------------------------------------
%% Resolves arguments in a generic way.
%%-----------------------------------------------------------------------

resolve_args(Args) -> [resolve_arg(A) || A <- Args].

resolve_arg({x,N} = Arg) when is_integer(N), N >= 0 -> Arg;
resolve_arg({y,N} = Arg) when is_integer(N), N >= 0 -> Arg;
resolve_arg({fr,N} = Arg) when is_integer(N), N >= 0 -> Arg;
resolve_arg({f,N} = Arg) when is_integer(N), N >= 0 -> Arg;
resolve_arg({u,_} = Arg) -> resolve_arg_unsigned(Arg);
resolve_arg({i,_} = Arg) -> resolve_arg_integer(Arg);
resolve_arg({atom,Atom} = Arg) when is_atom(Atom) -> Arg;
resolve_arg({float,F} = Arg) when is_float(F) -> Arg;
resolve_arg({literal,_} = Arg) -> Arg;
resolve_arg(nil) -> nil.

resolve_arg_unsigned({u,N}) when is_integer(N), N >= 0 -> N.

resolve_arg_integer({i,N}) when is_integer(N) -> {integer,N}.

%%-----------------------------------------------------------------------
%% The purpose of the following is just to add a hook for future changes.
%% Currently, field flags are numbers 1-2-4-8 and only two of these
%% numbers (BSF_LITTLE 2 -- BSF_SIGNED 4) have a semantic significance;
%% others are just hints for speeding up the execution; see "erl_bits.h".
%%-----------------------------------------------------------------------

decode_field_flags(FF) ->
    {field_flags,FF}.

%%-----------------------------------------------------------------------
%% Private Utilities
%%-----------------------------------------------------------------------

mk_imports(ImportList) ->
    gb_trees:from_orddict([{I,{extfunc,M,F,A}} || {I,M,F,A} <- ImportList]).

mk_atoms(AtomList) ->
    gb_trees:from_orddict(AtomList).

mk_labels(LabelList) ->
    gb_trees:from_orddict(LabelList).

lookup(I, Imports) ->
    gb_trees:get(I, Imports).
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             INDX( 	 DS1           (   p                             C
    ` J     Ho
   ) ^ږ8ږ8ږ,s                       d i s t N S E |
    ` P     Ho
   ) ږb2ږb2ږb2ږ       2              L I C E N S E ss
   2 p Z     Ho
   ) zCfږ0Inږ0Inږ,s                       n o d e _ m o d u l e s       ss
   2 h R     Ho
   ) zCfږ0Inږ0Inږ,s                       N O D E _ M ~ 1       }
    p Z     Ho
   ) qږATږ ATږ!Jž       i              p a c k a g e . j s o n       }
    p Z     Ho
   ) qږATږATږ!Jž       i              P A C K A G ~ 1 . J S O       ,q    h T     Ho
   ) ږ "ږ "ږ!ږ                      	R E A D M E . m d     |   
 X H     Ho
   ) t%cږTWdږTWdږV,s                       s r c                                                                                                                           